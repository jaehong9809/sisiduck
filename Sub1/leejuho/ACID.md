Transaction 논리적 작업단위

Atomicity 트랜잭션 실패시 롤백됨, 시스템이 다운되어도 성공한 쿼리는 커밋되지않았다면 롤백

### `일관성(Consistency)`

트랜잭션이 시작될 때와 끝날 때 데이터베이스의 상태가 **정합성**(validity)을 유지하도록 보장합니다. 일관성은 크게 두 가지 관점에서 이해할 수 있습니다:

1. **데이터 자체의 일관성**: 트랜잭션이 수행될 때, 데이터가 **규칙에 맞는 상태**를 유지해야 한다는 개념입니다.
2.

---

### 1. 데이터 자체의 일관성 (Consistency of Data)

**데이터 자체의 일관성**은 트랜잭션이 데이터베이스를 변경할 때 데이터베이스가 **정합성 제약조건**을 준수하도록 하는 원칙입니다. 예를 들어, 데이터베이스의 테이블에 설정된 **제약 조건**(primary key, foreign key, unique constraints 등)을 트랜잭션이 수행하는 동안 항상 만족해야 합니다.

- 트랜잭션이 시작되기 전과 끝난 후의 상태 모두가 **정합성 규칙을 만족**해야 합니다.
- 예를 들어, 하나의 트랜잭션에서 은행 계좌 이체를 처리할 때, 출금 계좌에서 돈을 빼고 입금 계좌에 돈을 추가할 때, 이 작업이 끝난 후에도 계좌들의 잔액이 일관된 상태여야 합니다.
- **트랜잭션 중에 오류가 발생하면, 데이터베이스는 원래 상태로 롤백**되어 일관성을 유지해야 합니다.

### 2. 읽기 과정에서의 일관성 (Consistency in Read Process)

**읽기 과정에서의 일관성**은 **동시성 제어(Concurrency Control)**와 밀접한 관련이 있으며, 여러 트랜잭션이 동시에 실행될 때 데이터가 일관되게 읽히는지에 대한 문제입니다. 주로 **동기화 복제(Synchronous Replication)**와 **비동기 복제(Asynchronous Replication)** 환경에서 어떻게 처리되는지를 기준으로 나누어 볼 수 있습니다.

### 2.1. 동기화 복제(Synchronous Replication)의 읽기 일관성(Strong Consistency)

동기화 복제에서는 **모든 노드**가 동일한 상태를 유지하도록 보장하기 위해, 하나의 노드에서 데이터가 변경되면 **모든 복제본에 즉시 반영**됩니다. 이 방식은 **읽기 일관성**을 보장할 수 있지만, **성능 상의 비용**이 발생합니다.

- **장점**:
    - 모든 복제본이 항상 동일하므로, **어떤 노드에서 데이터를 읽어도 최신 상태**의 데이터를 받을 수 있습니다.
    - **강한 일관성**을 보장합니다. 하나의 트랜잭션에서 변경된 데이터는 다른 트랜잭션이 읽을 수 있기 전에 **커밋되어야** 합니다.
- **단점**:
    - 데이터 변경 후, 모든 노드에 데이터가 반영될 때까지 기다려야 하므로, **성능**이 저하될 수 있습니다.
    - 노드 간의 네트워크 지연이나 오류 발생 시, **시스템 성능**에 큰 영향을 미칠 수 있습니다.

**예시**: 관계형 데이터베이스나 **주-복제**(master-slave) 구조에서 동기화 복제를 사용하면, 모든 복제본에 대한 데이터 일관성을 보장할 수 있습니다.

### 2.2. 비동기 복제(Asynchronous Replication)에서의 읽기 일관성

비동기 복제에서는 **데이터가 한 노드에서 변경되면, 그 변경 사항이 다른 복제본으로 전파되는 데 시간이 걸립니다**. 즉, 데이터 변경 후, 다른 노드에서 변경된 데이터를 바로 읽을 수 없습니다.

- **장점**:
    - 성능이 뛰어나며, 빠른 읽기/쓰기 성능을 제공합니다.
    - 각 노드에서 독립적으로 읽기를 할 수 있기 때문에 **높은 처리량**을 얻을 수 있습니다.
- **단점**:
    - **최신 데이터**를 읽지 못할 가능성이 있습니다. 일부 복제본에서는 **과거의 데이터**가 읽힐 수 있습니다. 이를 **잠재적 일관성**(Eventual Consistency)이라고 합니다.
    - **읽기 일관성**을 보장할 수 없으며, **stale read**(구식 읽기) 현상이 발생할 수 있습니다.

**예시**: **NoSQL 데이터베이스**나 **분산 시스템**에서 비동기 복제를 사용하면, 성능은 높지만 읽기 일관성이 깨질 수 있습니다. 이 방식은 `**최종 일관성**(Eventual Consistency)`을 따르며, 어느 정도 시간이 지나면 데이터가 일관되게 됩니다.

---

### 동기화 복제와 비동기 복제의 차이(강한 일관성, 최종 일관성)

| **특성** | **동기화 복제 (Synchronous Replication)** | **비동기 복제 (Asynchronous Replication)** |
| --- | --- | --- |
| **데이터 변경 반영** | 모든 복제본에 즉시 반영 | 변경 사항이 시간이 지나서 복제본에 반영 |
| **읽기 일관성** | 강한 일관성(Strong Consistency) 보장 | 최종 일관성(Eventual Consistency) |
| **성능** | 네트워크 지연으로 성능이 저하될 수 있음 | 성능이 뛰어남, 빠른 읽기/쓰기 가능 |
| **예시** | 관계형 DB, 주-복제 시스템에서 많이 사용 | NoSQL, 분산 시스템에서 많이 사용 |
| **장점** | 최신 데이터 보장 | 높은 처리량과 빠른 응답 시간 |
| **단점** | 성능 저하, 복제본 간 동기화 지연 | 일관성 없는 읽기(stale reads) 가능 |

---

### `트랜잭션 고립성(Isolation) 및 읽기 이상(Read Anomalies)`

트랜잭션 간에 서로 영향을 미치지 않도록 보장합니다.

고립성이 부족하면 여러 가지 **읽기 이상**(Read Anomalies) 현상이 발생할 수 있습니다.

| **읽기 이상(Read Anomaly)** | **설명** | **고립성 수준** |
| --- | --- | --- |
| **Dirty Read** | 트랜잭션 진행 중인 데이터를 다른 트랜잭션에서 읽을 수 있음. 커밋되지 않은 변경사항을 읽음. | **READ UNCOMMITTED** |
| **Non-repeatable Read** | 한 트랜잭션에서 같은 데이터를 여러 번 읽을 때, 다른 트랜잭션에서 변경된 내용을 반영한 결과가 도출됨. | **READ COMMITTED** |
| **Phantom Read** | 다른 트랜잭션에서 커밋된 새로운 행이 추가되어, 동일한 조건의 쿼리에서 다른 결과가 도출됨. | **REPEATABLE READ** |
| **Lost Update** | 두 트랜잭션이 같은 데이터를 수정하면서 서로의 변경 사항을 덮어쓰게 되어, 한 트랜잭션의 수정이 손실됨. | **SERIALIZABLE** |

---

### 트랜잭션 고립성 수준에 따른 읽기 이상

- **READ UNCOMMITTED**: 가장 낮은 고립성 수준으로, 다른 트랜잭션에서 아직 커밋되지 않은 데이터를 읽을 수 있습니다. 이는 **Dirty Read**를 발생시킬 수 있습니다.
- **READ COMMITTED**: 커밋된 데이터만 읽을 수 있도록 보장합니다. **Non-repeatable Read** 문제가 발생할 수 있습니다.
- **REPEATABLE READ**: 트랜잭션 내에서 읽은 데이터는 다른 트랜잭션에 의한 수정이 불가능합니다. **Phantom Read** 문제는 여전히 발생할 수 있습니다.
- **SERIALIZABLE**: 가장 높은 고립성 수준으로, 트랜잭션이 직렬화된 순서로 실행된 것처럼 보장됩니다. **Lost Update**가 발생하지 않도록 보장합니다.

---

Durability

트랜잭션이 성공적으로 커밋되면 DB에 저장된 사항이 영구적으로 보존되는 특성으로,

다만 디스크 손상과 같은 물리적인 장애에는 백업과 복구전략이 필요하다.

방법

- WAL writeAheadLog를 통해 로그로 기록되며 디스크에 기록되기전에 장애가 발생해도 로그를 통해 복구가 가능하다.
- Asynchronous Snapshot : 전체 데이터를 주기적으로 스냅샷 형태로 디스크에 저장.(DB의 읽기 쓰기 작업에 영향을 받지 않는다)

---

cf. MySQL에서 MVCC로 인해 기본격리수준은 repeatableRead지만 phantomRead가 발생하지 않는다.

→ 단, 유일하게

**SELECT -> INSERT -> SELECT FOR UPDATE의 경우에는 GapLock이 적용되지 않아 PantomRead가 발생**